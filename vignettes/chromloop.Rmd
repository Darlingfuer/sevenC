---
title: "Prediction of chromatin looping interactions with *chromloop*"
shorttitle: "chromloop package"
author: 
- name: Jonas Ibn-Salem
  affiliation:
  - &JGU Faculty of Biology, Johannes Gutenberg University of Mainz, 55128 Mainz, Germany
  - &IMB Institute of Molecular Biology, 55128 Mainz, Germany 
  email: j.ibn-salem@uni-mainz.de
- name: Miguel Andrade-Navarro
  affiliation:
    - *JGU
    - *IMB
package: chromloop
abstract: >
  Chromatin looping is an importent feature of
  eukaryotic genomes and can bring regulatory sequences, such as enhancers or 
  transcription factor binding sites, in close physical proximity of regulated 
  target genes.
  Here, we provide a tool that uses protein binding signals from ChIP-seq and
  sequence motif information to predict chromatin looping events. Cross-linking 
  of proteins that bind close to loop anchors result in ChIP-seq signals at both 
  anchor loci. These signals are used at CTCF motif pairs together with their 
  distance and orientation to each other to predict whether they interact or not.
  The resulting chromatin loops can be used to associate enhancers or 
  transcription factor binding sites (e.g. ChIP-seq peaks) to regulated target 
  genes.
output:
  BiocStyle::html_document:
    toc_float: true
  BiocStyle::pdf_document:
bibliography: chromloop.bib
vignette: >
  %\VignetteIndexEntry{Introduction to chromloop}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---
# Introduction

Gene expression is regulated by binding of transcription factors (TF) to genomic DNA. 
However, many binding sites are in distal regulatory region, such as enhancers, that are hundreds of kilo bases apart of genes.
These regulatory regions can physically interact with promoters of regulated genes by chromatin looping interactions. 
These looping interaction can be measured genome wide by chromatin conformation capture techniques such as Hi-C or ChIA-PET [@Rao2014, @Tang2015a]. Despite many exciting insights into the three-dimensional organization of genomes, these experimental methods are not only elaborate and expansive but also require require lots of sample material (in case of ChIA-PET) or have limited resolution of 5-40 kb (in case of Hi-C). 

In contrast, the binding sites of TFs can be detected genome-wide by ChIP-seq experiment which are available for hundreds of TFs in many cell type and conditions. However, classical analysis of ChIP-seq gives only the direct binding sites of targeted TFs (peaks) and it is not trivial to associate them to the regulated gene without chromatin looping information.

Therefore, we provide a computational method to predict chromatin interactions from only genomic sequence features and ChIP-seq data. 
The predicted looping interactions can be used to associate TF binding sites (ChIP-seq peaks) or enhancers to regulated genes and thereby improve functional downstream analysis on the level of genes.

In this vignette, we show how to use the R package `r BiocStyle::Biocpkg("chromloop")` to predict chromatin looping interactions between CTCF motifs by using only ChIP-seq data form a single experiment. 
Furthermore, we show how to train the the prediction model using custom data.

# Predict chromatin interaction form ChIP-seq

Here we show how to use the package to predict chromatin looping interactions 
among CTCF motif locations on chromosome 22. 
As input only a single bigWig file is used with coverage from a STAT1 ChIP-seq experiment 
in human GM12878 cells[^1]. 

[^1]: An example file with only data on a subset of chromosome 22 is provide as part of 
the `r BiocStyle::Biocpkg("chromloop")` package. The full file can be downloaded from ENCODE [@Dunham2012]  [here](http://hgdownload.cse.ucsc.edu/goldenPath/hg19/encodeDCC/wgEncodeSydhTfbs/wgEncodeSydhTfbsGm12878Stat1StdSig.bigWig).

## Prepare CTCF motif pairs
First, we need to prepare CTCF motif pairs as candidate anchors for chromatin loop interactions. 
We use CTCF motif hits in human chromosome 22 as provide by `r BiocStyle::Biocpkg("chromloop")` package.

```{r, results = "hide", message = FALSE}
library(chromloop)

# load provided CTCF motifs
motifs <- motif.hg19.CTCF.chr22
```
The CTCF motif are represented as `GRanges` object from the `r BiocStyle::Biocpkg("GenomicRanges")` package. 

```{r}
class(motifs)

motifs
```
There are `r length(motifs)` CTCF motif locations on chromosome 22. 
The genome assembly is hg19. 
Four metadata columns show motif match similarity as weight score, p-value, log transformed p-value and significance score. 
Use `help(motif.hg19.CTCF)` to get more information on the motif dataset.

### Add ChIP-seq signals at motifs sites

To predict loops we need the ChIP-seq signals at all motif sites. 
Therefore, we read an example bigWig file with ChIP-seq signals^[Note, reading of bigWig files is currently not supported on Windows. 
See `help(rtracklayer::import.bw)` for more information. Users on Windows need to add coverage signals as `NumierList` by other means.]. 
For each position along the genome, the file contains the log fold-change of ChIP signals compared to input control. 
A sample file with data on a subset of chromosome 22 is provided in the package. 
```{r}
# use example ChIP-seq bigWig file
bigWigFile <- system.file("extdata", "GM12878_Stat1.chr22_1-18000000.bigWig", 
  package = "chromloop")
```

We add ChIP-seq signals to all motifs in a window of 1000 bp using the function `addCovToGR()` as follows
```{r eval = FALSE}
# read ChIP-seq coverage 
motifs <- addCovToGR(motifs, bigWigFile)
```

```{r eval = TRUE, echo = FALSE}
# check if OS is windows
if (.Platform$OS.type == 'windows') {
  motifs <- motif.hg19.CTCF.chr22.cov
} else {
  # read ChIP-seq coverage 
  motifs <- addCovToGR(motifs, bigWigFile)
}
```


This adds a new metadata column to `motifs` holding a `NumericList` with ChIP-seq signals for each motif location. 
```{r}
motifs$cov
```



### Build pairs of motifs as candidate interactions

Now we build a dataset with all pairs of CTCF motif within 1 Mb and annotate it with distance, motif orientation, and motif score. 
```{r}
gi <- prepareCandidates(motifs, maxDist = 10^6, scoreColname = "sig")

gi
```
The function `prepareCandidates()` returns a `GInteractoin` object from the `r BiocStyle::Biocpkg("InteractonSet")` package. 
Metadata columns of the `GInteractoin` object hold the genomic distance between motifs in bp (`dist`), the orientation of motifs (`strandOrientation`), and motif score as -log~10~ of the motif hit p-value (`score_1`, `score_2`, and `score_min`). 

## Compute similarity at motif pairs

Now, we compute the correlation of ChIP-seq signals for all motif pairs.
The correlation coefficient is added as additional metadata column to `gi`.
```{r}
# add ChIP-seq coverage and compute correaltion at motif pairs
gi <- addCovCor(gi)
```

## Predict loops
Now we can predict chromatin loops using the default trained model. 
```{r}
loops <- predLoops(gi)

loops
```
This result in a subset of motif pairs that are predicted to interact. The interactions are annotated with ChIP-seq correlation in column `chip` and interaction probability in `pred`.

## Write predicted loops to output file
Since looping interactions are stored as `GInteraction` objects, they 
can be exported as 
[BED-PE](http://bedtools.readthedocs.io/en/latest/content/general-usage.html#bedpe-format) 
files using functions from `r BiocStyle::Biocpkg("GenomicInteractions")` package.

```{r, message = FALSE}
require(GenomicInteractions)

# export to output file
export.bedpe(loops, "loop_interactions.bedpe", score = "pred")

```


# Train prediciton model using custom data
Here, we show how to use  `r BiocStyle::Biocpkg("chromloop")` to build and train a logistic regression model for loop prediction. 

## Prepare moitf pairs and add ChIP-seq data
First, we need to build the pairs of motifs as candidate and add the ChIP-seq data as shown above. 

```{r eval = FALSE, echo = TRUE}
# load provided CTCF motifs
motifs <- motif.hg19.CTCF.chr22

# use example ChIP-seq coverage file
bigWigFile <- system.file("extdata", "GM12878_Stat1.chr22_1-18000000.bigWig", 
  package = "chromloop")

# add ChIP-seq coverage
motifs <- addCovToGR(motifs, bigWigFile)

# build motif pairs
gi <- prepareCandidates(motifs, maxDist = 10^6, scoreColname = "sig")

# add correaltion of ChIP-signal
gi <- addCovCor(gi)
```

```{r eval = TRUE, echo = FALSE}
# check if OS is windows
if (.Platform$OS.type == 'windows') {
  motifs <- motif.hg19.CTCF.chr22.cov
} else {
  # load provided CTCF motifs
  motifs <- motif.hg19.CTCF.chr22
  
  # use example ChIP-seq coverage file
  bigWigFile <- system.file("extdata", "GM12878_Stat1.chr22_1-18000000.bigWig", 
    package = "chromloop")
  
  # add ChIP-seq coverage
  motifs <- addCovToGR(motifs, bigWigFile)
}
  
gi <- prepareCandidates(motifs, maxDist = 10^6, scoreColname = "sig")

# add correaltion of ChIP-signal
gi <- addCovCor(gi)
```

## Train predictor with known loops

We need to label true looping interactions by using experimental data of chromatin interactions. 
Here, we use loops from high resolution Hi-C experiments in human GM12878 cells [@Rao2014].
An example file with loops on chromosome 22 is provided with the `r BiocStyle::Biocpkg("chromloop")` package and the function `parseLoopsRao()` reads loops in the format provided by Rao et al. and returns a `GInteraction` object.
We can add a new metadata column to the motif pairs indicating whether the pair is interacting in the experimental data using the function `addInteractionSupport()`.

```{r}
# parse known loops
knownLoopFile <- system.file("extdata", 
  "GM12878_HiCCUPS.chr22_1-18000000.loop.txt", package = "chromloop")

knownLoops <- parseLoopsRao(knownLoopFile)

# add known loops
gi <- addInteractionSupport(gi, knownLoops)
```
The experimental support is added as factor with levels `"Loop"` and `"No loop"` as metadata column named `loop` (which can be modified using the `colname` argument).

## Train logistic regression model 
We can use the `glm()` function in R to fit a logistic regression model in which the `loop` column is the dependent variable and the ChIP-seq correlation, distance, and strandOrientation are the predictors. 

```{r}
fit <- glm(
  formula = loop ~ cor_chip + dist + strandOrientation, 
  data = mcols(gi), 
  family = binomial()
  )
```

## Predict loops with custom model
Now, we can use this model to add predicted looping probabilities.

```{r}
# add predict loops
gi <- predLoops(
  gi,
  formula = loop ~ cor_chip + dist + strandOrientation,
  betas = coef(fit),
  cutoff = NULL
)
```
Here, we have to use the same formula as argument as in the model fitting step above. 
The `betas` argument takes the coefficients of the logistic regression model.
Finally, the argument `cutoff = NULL` ensures that no filtering is done and all input candidates are reported.
The prediction score is added as a new metadata column to `gi`.
```{r}
gi 
```

As a very simple validation we can now compare the prediction score for looping and non-looping motif pairs using a boxplot.

```{r, fig.width = 6}
boxplot(gi$pred ~ gi$loop)

```
This shows higher prediction scores for truly looping motif pairs.
However, this is an insufficient evaluation of prediction performance, since the prediction score is evaluated on the same data as it was trained. 
A more detailed evaluation of prediction performance using cross-validation and different cell types is soon available in the chromloop paper. 

# References

